// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package eventstorecloud

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages EventStoreDB instances and clusters in Event Store Cloud
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-eventstorecloud/sdk/go/eventstorecloud"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := eventstorecloud.LookupProject(ctx, &GetProjectArgs{
// 			Name: "Example Project",
// 		}, nil)
// 		if err != nil {
// 			return err
// 		}
// 		exampleNetwork, err := eventstorecloud.NewNetwork(ctx, "exampleNetwork", &eventstorecloud.NetworkArgs{
// 			ProjectId:        pulumi.Any(eventstorecloud_project.Example.Id),
// 			ResourceProvider: pulumi.String("aws"),
// 			Region:           pulumi.String("us-west-2"),
// 			CidrBlock:        pulumi.String("172.21.0.0/16"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = eventstorecloud.NewManagedCluster(ctx, "exampleManagedCluster", &eventstorecloud.ManagedClusterArgs{
// 			ProjectId:     exampleNetwork.ProjectId,
// 			NetworkId:     exampleNetwork.ID(),
// 			Topology:      pulumi.String("three-node-multi-zone"),
// 			InstanceType:  pulumi.String("F1"),
// 			DiskSize:      pulumi.Int(24),
// 			DiskType:      pulumi.String("gp2"),
// 			ServerVersion: pulumi.String("20.6"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// ```sh
//  $ pulumi import eventstorecloud:index/managedCluster:ManagedCluster example project_id:cluster_id
// ```
type ManagedCluster struct {
	pulumi.CustomResourceState

	// Size of the data disks, in gigabytes
	DiskSize pulumi.IntOutput `pulumi:"diskSize"`
	// Storage class of the data disks (find the list of valid values below)
	DiskType pulumi.StringOutput `pulumi:"diskType"`
	// DNS address of the cluster
	DnsName pulumi.StringOutput `pulumi:"dnsName"`
	// Instance type of the managed cluster (find the list of valid values below)
	InstanceType pulumi.StringOutput `pulumi:"instanceType"`
	// Name of the managed cluster
	Name pulumi.StringOutput `pulumi:"name"`
	// ID of the network in which the managed cluster exists
	NetworkId pulumi.StringOutput `pulumi:"networkId"`
	// ID of the project in which the managed cluster exists
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// Determines whether to run no projections, system projections only, or system and user projections (find the list of valid values below) Defaults to `off`.
	ProjectionLevel pulumi.StringPtrOutput `pulumi:"projectionLevel"`
	// Region in which the cluster was created. Determined by the region of the Network
	Region pulumi.StringOutput `pulumi:"region"`
	// Provider in which the cluster was created. Determined by the provider of the Network.
	ResourceProvider pulumi.StringOutput `pulumi:"resourceProvider"`
	// Server version to provision (find the list of valid values below)
	ServerVersion pulumi.StringOutput `pulumi:"serverVersion"`
	// Topology of the managed cluster (`single-node` or `three-node-multi-zone`)
	Topology pulumi.StringOutput `pulumi:"topology"`
}

// NewManagedCluster registers a new resource with the given unique name, arguments, and options.
func NewManagedCluster(ctx *pulumi.Context,
	name string, args *ManagedClusterArgs, opts ...pulumi.ResourceOption) (*ManagedCluster, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DiskSize == nil {
		return nil, errors.New("invalid value for required argument 'DiskSize'")
	}
	if args.DiskType == nil {
		return nil, errors.New("invalid value for required argument 'DiskType'")
	}
	if args.InstanceType == nil {
		return nil, errors.New("invalid value for required argument 'InstanceType'")
	}
	if args.NetworkId == nil {
		return nil, errors.New("invalid value for required argument 'NetworkId'")
	}
	if args.ProjectId == nil {
		return nil, errors.New("invalid value for required argument 'ProjectId'")
	}
	if args.ServerVersion == nil {
		return nil, errors.New("invalid value for required argument 'ServerVersion'")
	}
	if args.Topology == nil {
		return nil, errors.New("invalid value for required argument 'Topology'")
	}
	var resource ManagedCluster
	err := ctx.RegisterResource("eventstorecloud:index/managedCluster:ManagedCluster", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetManagedCluster gets an existing ManagedCluster resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetManagedCluster(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ManagedClusterState, opts ...pulumi.ResourceOption) (*ManagedCluster, error) {
	var resource ManagedCluster
	err := ctx.ReadResource("eventstorecloud:index/managedCluster:ManagedCluster", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ManagedCluster resources.
type managedClusterState struct {
	// Size of the data disks, in gigabytes
	DiskSize *int `pulumi:"diskSize"`
	// Storage class of the data disks (find the list of valid values below)
	DiskType *string `pulumi:"diskType"`
	// DNS address of the cluster
	DnsName *string `pulumi:"dnsName"`
	// Instance type of the managed cluster (find the list of valid values below)
	InstanceType *string `pulumi:"instanceType"`
	// Name of the managed cluster
	Name *string `pulumi:"name"`
	// ID of the network in which the managed cluster exists
	NetworkId *string `pulumi:"networkId"`
	// ID of the project in which the managed cluster exists
	ProjectId *string `pulumi:"projectId"`
	// Determines whether to run no projections, system projections only, or system and user projections (find the list of valid values below) Defaults to `off`.
	ProjectionLevel *string `pulumi:"projectionLevel"`
	// Region in which the cluster was created. Determined by the region of the Network
	Region *string `pulumi:"region"`
	// Provider in which the cluster was created. Determined by the provider of the Network.
	ResourceProvider *string `pulumi:"resourceProvider"`
	// Server version to provision (find the list of valid values below)
	ServerVersion *string `pulumi:"serverVersion"`
	// Topology of the managed cluster (`single-node` or `three-node-multi-zone`)
	Topology *string `pulumi:"topology"`
}

type ManagedClusterState struct {
	// Size of the data disks, in gigabytes
	DiskSize pulumi.IntPtrInput
	// Storage class of the data disks (find the list of valid values below)
	DiskType pulumi.StringPtrInput
	// DNS address of the cluster
	DnsName pulumi.StringPtrInput
	// Instance type of the managed cluster (find the list of valid values below)
	InstanceType pulumi.StringPtrInput
	// Name of the managed cluster
	Name pulumi.StringPtrInput
	// ID of the network in which the managed cluster exists
	NetworkId pulumi.StringPtrInput
	// ID of the project in which the managed cluster exists
	ProjectId pulumi.StringPtrInput
	// Determines whether to run no projections, system projections only, or system and user projections (find the list of valid values below) Defaults to `off`.
	ProjectionLevel pulumi.StringPtrInput
	// Region in which the cluster was created. Determined by the region of the Network
	Region pulumi.StringPtrInput
	// Provider in which the cluster was created. Determined by the provider of the Network.
	ResourceProvider pulumi.StringPtrInput
	// Server version to provision (find the list of valid values below)
	ServerVersion pulumi.StringPtrInput
	// Topology of the managed cluster (`single-node` or `three-node-multi-zone`)
	Topology pulumi.StringPtrInput
}

func (ManagedClusterState) ElementType() reflect.Type {
	return reflect.TypeOf((*managedClusterState)(nil)).Elem()
}

type managedClusterArgs struct {
	// Size of the data disks, in gigabytes
	DiskSize int `pulumi:"diskSize"`
	// Storage class of the data disks (find the list of valid values below)
	DiskType string `pulumi:"diskType"`
	// Instance type of the managed cluster (find the list of valid values below)
	InstanceType string `pulumi:"instanceType"`
	// Name of the managed cluster
	Name *string `pulumi:"name"`
	// ID of the network in which the managed cluster exists
	NetworkId string `pulumi:"networkId"`
	// ID of the project in which the managed cluster exists
	ProjectId string `pulumi:"projectId"`
	// Determines whether to run no projections, system projections only, or system and user projections (find the list of valid values below) Defaults to `off`.
	ProjectionLevel *string `pulumi:"projectionLevel"`
	// Server version to provision (find the list of valid values below)
	ServerVersion string `pulumi:"serverVersion"`
	// Topology of the managed cluster (`single-node` or `three-node-multi-zone`)
	Topology string `pulumi:"topology"`
}

// The set of arguments for constructing a ManagedCluster resource.
type ManagedClusterArgs struct {
	// Size of the data disks, in gigabytes
	DiskSize pulumi.IntInput
	// Storage class of the data disks (find the list of valid values below)
	DiskType pulumi.StringInput
	// Instance type of the managed cluster (find the list of valid values below)
	InstanceType pulumi.StringInput
	// Name of the managed cluster
	Name pulumi.StringPtrInput
	// ID of the network in which the managed cluster exists
	NetworkId pulumi.StringInput
	// ID of the project in which the managed cluster exists
	ProjectId pulumi.StringInput
	// Determines whether to run no projections, system projections only, or system and user projections (find the list of valid values below) Defaults to `off`.
	ProjectionLevel pulumi.StringPtrInput
	// Server version to provision (find the list of valid values below)
	ServerVersion pulumi.StringInput
	// Topology of the managed cluster (`single-node` or `three-node-multi-zone`)
	Topology pulumi.StringInput
}

func (ManagedClusterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*managedClusterArgs)(nil)).Elem()
}

type ManagedClusterInput interface {
	pulumi.Input

	ToManagedClusterOutput() ManagedClusterOutput
	ToManagedClusterOutputWithContext(ctx context.Context) ManagedClusterOutput
}

func (*ManagedCluster) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedCluster)(nil))
}

func (i *ManagedCluster) ToManagedClusterOutput() ManagedClusterOutput {
	return i.ToManagedClusterOutputWithContext(context.Background())
}

func (i *ManagedCluster) ToManagedClusterOutputWithContext(ctx context.Context) ManagedClusterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedClusterOutput)
}

func (i *ManagedCluster) ToManagedClusterPtrOutput() ManagedClusterPtrOutput {
	return i.ToManagedClusterPtrOutputWithContext(context.Background())
}

func (i *ManagedCluster) ToManagedClusterPtrOutputWithContext(ctx context.Context) ManagedClusterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedClusterPtrOutput)
}

type ManagedClusterPtrInput interface {
	pulumi.Input

	ToManagedClusterPtrOutput() ManagedClusterPtrOutput
	ToManagedClusterPtrOutputWithContext(ctx context.Context) ManagedClusterPtrOutput
}

type managedClusterPtrType ManagedClusterArgs

func (*managedClusterPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedCluster)(nil))
}

func (i *managedClusterPtrType) ToManagedClusterPtrOutput() ManagedClusterPtrOutput {
	return i.ToManagedClusterPtrOutputWithContext(context.Background())
}

func (i *managedClusterPtrType) ToManagedClusterPtrOutputWithContext(ctx context.Context) ManagedClusterPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedClusterPtrOutput)
}

// ManagedClusterArrayInput is an input type that accepts ManagedClusterArray and ManagedClusterArrayOutput values.
// You can construct a concrete instance of `ManagedClusterArrayInput` via:
//
//          ManagedClusterArray{ ManagedClusterArgs{...} }
type ManagedClusterArrayInput interface {
	pulumi.Input

	ToManagedClusterArrayOutput() ManagedClusterArrayOutput
	ToManagedClusterArrayOutputWithContext(context.Context) ManagedClusterArrayOutput
}

type ManagedClusterArray []ManagedClusterInput

func (ManagedClusterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ManagedCluster)(nil)).Elem()
}

func (i ManagedClusterArray) ToManagedClusterArrayOutput() ManagedClusterArrayOutput {
	return i.ToManagedClusterArrayOutputWithContext(context.Background())
}

func (i ManagedClusterArray) ToManagedClusterArrayOutputWithContext(ctx context.Context) ManagedClusterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedClusterArrayOutput)
}

// ManagedClusterMapInput is an input type that accepts ManagedClusterMap and ManagedClusterMapOutput values.
// You can construct a concrete instance of `ManagedClusterMapInput` via:
//
//          ManagedClusterMap{ "key": ManagedClusterArgs{...} }
type ManagedClusterMapInput interface {
	pulumi.Input

	ToManagedClusterMapOutput() ManagedClusterMapOutput
	ToManagedClusterMapOutputWithContext(context.Context) ManagedClusterMapOutput
}

type ManagedClusterMap map[string]ManagedClusterInput

func (ManagedClusterMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ManagedCluster)(nil)).Elem()
}

func (i ManagedClusterMap) ToManagedClusterMapOutput() ManagedClusterMapOutput {
	return i.ToManagedClusterMapOutputWithContext(context.Background())
}

func (i ManagedClusterMap) ToManagedClusterMapOutputWithContext(ctx context.Context) ManagedClusterMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedClusterMapOutput)
}

type ManagedClusterOutput struct{ *pulumi.OutputState }

func (ManagedClusterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*ManagedCluster)(nil))
}

func (o ManagedClusterOutput) ToManagedClusterOutput() ManagedClusterOutput {
	return o
}

func (o ManagedClusterOutput) ToManagedClusterOutputWithContext(ctx context.Context) ManagedClusterOutput {
	return o
}

func (o ManagedClusterOutput) ToManagedClusterPtrOutput() ManagedClusterPtrOutput {
	return o.ToManagedClusterPtrOutputWithContext(context.Background())
}

func (o ManagedClusterOutput) ToManagedClusterPtrOutputWithContext(ctx context.Context) ManagedClusterPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v ManagedCluster) *ManagedCluster {
		return &v
	}).(ManagedClusterPtrOutput)
}

type ManagedClusterPtrOutput struct{ *pulumi.OutputState }

func (ManagedClusterPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedCluster)(nil))
}

func (o ManagedClusterPtrOutput) ToManagedClusterPtrOutput() ManagedClusterPtrOutput {
	return o
}

func (o ManagedClusterPtrOutput) ToManagedClusterPtrOutputWithContext(ctx context.Context) ManagedClusterPtrOutput {
	return o
}

func (o ManagedClusterPtrOutput) Elem() ManagedClusterOutput {
	return o.ApplyT(func(v *ManagedCluster) ManagedCluster {
		if v != nil {
			return *v
		}
		var ret ManagedCluster
		return ret
	}).(ManagedClusterOutput)
}

type ManagedClusterArrayOutput struct{ *pulumi.OutputState }

func (ManagedClusterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]ManagedCluster)(nil))
}

func (o ManagedClusterArrayOutput) ToManagedClusterArrayOutput() ManagedClusterArrayOutput {
	return o
}

func (o ManagedClusterArrayOutput) ToManagedClusterArrayOutputWithContext(ctx context.Context) ManagedClusterArrayOutput {
	return o
}

func (o ManagedClusterArrayOutput) Index(i pulumi.IntInput) ManagedClusterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) ManagedCluster {
		return vs[0].([]ManagedCluster)[vs[1].(int)]
	}).(ManagedClusterOutput)
}

type ManagedClusterMapOutput struct{ *pulumi.OutputState }

func (ManagedClusterMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]ManagedCluster)(nil))
}

func (o ManagedClusterMapOutput) ToManagedClusterMapOutput() ManagedClusterMapOutput {
	return o
}

func (o ManagedClusterMapOutput) ToManagedClusterMapOutputWithContext(ctx context.Context) ManagedClusterMapOutput {
	return o
}

func (o ManagedClusterMapOutput) MapIndex(k pulumi.StringInput) ManagedClusterOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) ManagedCluster {
		return vs[0].(map[string]ManagedCluster)[vs[1].(string)]
	}).(ManagedClusterOutput)
}

func init() {
	pulumi.RegisterOutputType(ManagedClusterOutput{})
	pulumi.RegisterOutputType(ManagedClusterPtrOutput{})
	pulumi.RegisterOutputType(ManagedClusterArrayOutput{})
	pulumi.RegisterOutputType(ManagedClusterMapOutput{})
}
