// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package eventstorecloud

import (
	"context"
	"reflect"

	"errors"
	"github.com/EventStore/pulumi-eventstorecloud/sdk/go/eventstorecloud/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages EventStoreDB instances and clusters in Event Store Cloud
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/EventStore/pulumi-eventstorecloud/sdk/go/eventstorecloud"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := eventstorecloud.LookupProject(ctx, &eventstorecloud.LookupProjectArgs{
//				Name: "Example Project",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			exampleNetwork, err := eventstorecloud.NewNetwork(ctx, "exampleNetwork", &eventstorecloud.NetworkArgs{
//				ProjectId:        pulumi.Any(eventstorecloud_project.Example.Id),
//				ResourceProvider: pulumi.String("aws"),
//				Region:           pulumi.String("us-west-2"),
//				CidrBlock:        pulumi.String("172.21.0.0/16"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = eventstorecloud.NewManagedCluster(ctx, "exampleManagedCluster", &eventstorecloud.ManagedClusterArgs{
//				ProjectId:      exampleNetwork.ProjectId,
//				NetworkId:      exampleNetwork.ID(),
//				Topology:       pulumi.String("three-node-multi-zone"),
//				InstanceType:   pulumi.String("F1"),
//				DiskSize:       pulumi.Int(24),
//				DiskType:       pulumi.String("gp3"),
//				DiskIops:       pulumi.Int(3000),
//				DiskThroughput: pulumi.Int(125),
//				ServerVersion:  pulumi.String("20.6"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
//
//	$ pulumi import eventstorecloud:index/managedCluster:ManagedCluster example project_id:cluster_id
//
// ```
type ManagedCluster struct {
	pulumi.CustomResourceState

	// Number of IOPS for storage, required if diskType is `gp3`
	DiskIops pulumi.IntPtrOutput `pulumi:"diskIops"`
	// Size of the data disks, in gigabytes
	DiskSize pulumi.IntOutput `pulumi:"diskSize"`
	// Throughput in MB/s for storage, required if diskType is `gp3`
	DiskThroughput pulumi.IntPtrOutput `pulumi:"diskThroughput"`
	// Storage class of the data disks (find the list of valid values below)
	DiskType pulumi.StringOutput `pulumi:"diskType"`
	// DNS address of the cluster
	DnsName pulumi.StringOutput `pulumi:"dnsName"`
	// Instance type of the managed cluster (find the list of valid values below)
	InstanceType pulumi.StringOutput `pulumi:"instanceType"`
	// Name of the managed cluster
	Name pulumi.StringOutput `pulumi:"name"`
	// ID of the network in which the managed cluster exists
	NetworkId pulumi.StringOutput `pulumi:"networkId"`
	// ID of the project in which the managed cluster exists
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// Determines whether to run no projections, system projections only, or system and user projections (find the list of valid values below) Defaults to `off`.
	ProjectionLevel pulumi.StringPtrOutput `pulumi:"projectionLevel"`
	// Protection from an accidental cluster deletion Defaults to `false`.
	Protected pulumi.BoolPtrOutput `pulumi:"protected"`
	// Region in which the cluster was created. Determined by the region of the Network
	Region pulumi.StringOutput `pulumi:"region"`
	// Provider in which the cluster was created. Determined by the provider of the Network.
	ResourceProvider pulumi.StringOutput `pulumi:"resourceProvider"`
	// Server version to provision (find the list of valid values below)
	ServerVersion pulumi.StringOutput `pulumi:"serverVersion"`
	// Server version tag to upgrade to (find the list of valid values below). If a tag is provided and it's higher than what's in state, this will prompt an in-place upgrade.
	ServerVersionTag pulumi.StringOutput `pulumi:"serverVersionTag"`
	// Topology of the managed cluster (`single-node` or `three-node-multi-zone`)
	Topology pulumi.StringOutput `pulumi:"topology"`
}

// NewManagedCluster registers a new resource with the given unique name, arguments, and options.
func NewManagedCluster(ctx *pulumi.Context,
	name string, args *ManagedClusterArgs, opts ...pulumi.ResourceOption) (*ManagedCluster, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DiskSize == nil {
		return nil, errors.New("invalid value for required argument 'DiskSize'")
	}
	if args.DiskType == nil {
		return nil, errors.New("invalid value for required argument 'DiskType'")
	}
	if args.InstanceType == nil {
		return nil, errors.New("invalid value for required argument 'InstanceType'")
	}
	if args.NetworkId == nil {
		return nil, errors.New("invalid value for required argument 'NetworkId'")
	}
	if args.ProjectId == nil {
		return nil, errors.New("invalid value for required argument 'ProjectId'")
	}
	if args.ServerVersion == nil {
		return nil, errors.New("invalid value for required argument 'ServerVersion'")
	}
	if args.Topology == nil {
		return nil, errors.New("invalid value for required argument 'Topology'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ManagedCluster
	err := ctx.RegisterResource("eventstorecloud:index/managedCluster:ManagedCluster", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetManagedCluster gets an existing ManagedCluster resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetManagedCluster(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ManagedClusterState, opts ...pulumi.ResourceOption) (*ManagedCluster, error) {
	var resource ManagedCluster
	err := ctx.ReadResource("eventstorecloud:index/managedCluster:ManagedCluster", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ManagedCluster resources.
type managedClusterState struct {
	// Number of IOPS for storage, required if diskType is `gp3`
	DiskIops *int `pulumi:"diskIops"`
	// Size of the data disks, in gigabytes
	DiskSize *int `pulumi:"diskSize"`
	// Throughput in MB/s for storage, required if diskType is `gp3`
	DiskThroughput *int `pulumi:"diskThroughput"`
	// Storage class of the data disks (find the list of valid values below)
	DiskType *string `pulumi:"diskType"`
	// DNS address of the cluster
	DnsName *string `pulumi:"dnsName"`
	// Instance type of the managed cluster (find the list of valid values below)
	InstanceType *string `pulumi:"instanceType"`
	// Name of the managed cluster
	Name *string `pulumi:"name"`
	// ID of the network in which the managed cluster exists
	NetworkId *string `pulumi:"networkId"`
	// ID of the project in which the managed cluster exists
	ProjectId *string `pulumi:"projectId"`
	// Determines whether to run no projections, system projections only, or system and user projections (find the list of valid values below) Defaults to `off`.
	ProjectionLevel *string `pulumi:"projectionLevel"`
	// Protection from an accidental cluster deletion Defaults to `false`.
	Protected *bool `pulumi:"protected"`
	// Region in which the cluster was created. Determined by the region of the Network
	Region *string `pulumi:"region"`
	// Provider in which the cluster was created. Determined by the provider of the Network.
	ResourceProvider *string `pulumi:"resourceProvider"`
	// Server version to provision (find the list of valid values below)
	ServerVersion *string `pulumi:"serverVersion"`
	// Server version tag to upgrade to (find the list of valid values below). If a tag is provided and it's higher than what's in state, this will prompt an in-place upgrade.
	ServerVersionTag *string `pulumi:"serverVersionTag"`
	// Topology of the managed cluster (`single-node` or `three-node-multi-zone`)
	Topology *string `pulumi:"topology"`
}

type ManagedClusterState struct {
	// Number of IOPS for storage, required if diskType is `gp3`
	DiskIops pulumi.IntPtrInput
	// Size of the data disks, in gigabytes
	DiskSize pulumi.IntPtrInput
	// Throughput in MB/s for storage, required if diskType is `gp3`
	DiskThroughput pulumi.IntPtrInput
	// Storage class of the data disks (find the list of valid values below)
	DiskType pulumi.StringPtrInput
	// DNS address of the cluster
	DnsName pulumi.StringPtrInput
	// Instance type of the managed cluster (find the list of valid values below)
	InstanceType pulumi.StringPtrInput
	// Name of the managed cluster
	Name pulumi.StringPtrInput
	// ID of the network in which the managed cluster exists
	NetworkId pulumi.StringPtrInput
	// ID of the project in which the managed cluster exists
	ProjectId pulumi.StringPtrInput
	// Determines whether to run no projections, system projections only, or system and user projections (find the list of valid values below) Defaults to `off`.
	ProjectionLevel pulumi.StringPtrInput
	// Protection from an accidental cluster deletion Defaults to `false`.
	Protected pulumi.BoolPtrInput
	// Region in which the cluster was created. Determined by the region of the Network
	Region pulumi.StringPtrInput
	// Provider in which the cluster was created. Determined by the provider of the Network.
	ResourceProvider pulumi.StringPtrInput
	// Server version to provision (find the list of valid values below)
	ServerVersion pulumi.StringPtrInput
	// Server version tag to upgrade to (find the list of valid values below). If a tag is provided and it's higher than what's in state, this will prompt an in-place upgrade.
	ServerVersionTag pulumi.StringPtrInput
	// Topology of the managed cluster (`single-node` or `three-node-multi-zone`)
	Topology pulumi.StringPtrInput
}

func (ManagedClusterState) ElementType() reflect.Type {
	return reflect.TypeOf((*managedClusterState)(nil)).Elem()
}

type managedClusterArgs struct {
	// Number of IOPS for storage, required if diskType is `gp3`
	DiskIops *int `pulumi:"diskIops"`
	// Size of the data disks, in gigabytes
	DiskSize int `pulumi:"diskSize"`
	// Throughput in MB/s for storage, required if diskType is `gp3`
	DiskThroughput *int `pulumi:"diskThroughput"`
	// Storage class of the data disks (find the list of valid values below)
	DiskType string `pulumi:"diskType"`
	// Instance type of the managed cluster (find the list of valid values below)
	InstanceType string `pulumi:"instanceType"`
	// Name of the managed cluster
	Name *string `pulumi:"name"`
	// ID of the network in which the managed cluster exists
	NetworkId string `pulumi:"networkId"`
	// ID of the project in which the managed cluster exists
	ProjectId string `pulumi:"projectId"`
	// Determines whether to run no projections, system projections only, or system and user projections (find the list of valid values below) Defaults to `off`.
	ProjectionLevel *string `pulumi:"projectionLevel"`
	// Protection from an accidental cluster deletion Defaults to `false`.
	Protected *bool `pulumi:"protected"`
	// Server version to provision (find the list of valid values below)
	ServerVersion string `pulumi:"serverVersion"`
	// Server version tag to upgrade to (find the list of valid values below). If a tag is provided and it's higher than what's in state, this will prompt an in-place upgrade.
	ServerVersionTag *string `pulumi:"serverVersionTag"`
	// Topology of the managed cluster (`single-node` or `three-node-multi-zone`)
	Topology string `pulumi:"topology"`
}

// The set of arguments for constructing a ManagedCluster resource.
type ManagedClusterArgs struct {
	// Number of IOPS for storage, required if diskType is `gp3`
	DiskIops pulumi.IntPtrInput
	// Size of the data disks, in gigabytes
	DiskSize pulumi.IntInput
	// Throughput in MB/s for storage, required if diskType is `gp3`
	DiskThroughput pulumi.IntPtrInput
	// Storage class of the data disks (find the list of valid values below)
	DiskType pulumi.StringInput
	// Instance type of the managed cluster (find the list of valid values below)
	InstanceType pulumi.StringInput
	// Name of the managed cluster
	Name pulumi.StringPtrInput
	// ID of the network in which the managed cluster exists
	NetworkId pulumi.StringInput
	// ID of the project in which the managed cluster exists
	ProjectId pulumi.StringInput
	// Determines whether to run no projections, system projections only, or system and user projections (find the list of valid values below) Defaults to `off`.
	ProjectionLevel pulumi.StringPtrInput
	// Protection from an accidental cluster deletion Defaults to `false`.
	Protected pulumi.BoolPtrInput
	// Server version to provision (find the list of valid values below)
	ServerVersion pulumi.StringInput
	// Server version tag to upgrade to (find the list of valid values below). If a tag is provided and it's higher than what's in state, this will prompt an in-place upgrade.
	ServerVersionTag pulumi.StringInput
	// Topology of the managed cluster (`single-node` or `three-node-multi-zone`)
	Topology pulumi.StringInput
}

func (ManagedClusterArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*managedClusterArgs)(nil)).Elem()
}

type ManagedClusterInput interface {
	pulumi.Input

	ToManagedClusterOutput() ManagedClusterOutput
	ToManagedClusterOutputWithContext(ctx context.Context) ManagedClusterOutput
}

func (*ManagedCluster) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedCluster)(nil)).Elem()
}

func (i *ManagedCluster) ToManagedClusterOutput() ManagedClusterOutput {
	return i.ToManagedClusterOutputWithContext(context.Background())
}

func (i *ManagedCluster) ToManagedClusterOutputWithContext(ctx context.Context) ManagedClusterOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedClusterOutput)
}

// ManagedClusterArrayInput is an input type that accepts ManagedClusterArray and ManagedClusterArrayOutput values.
// You can construct a concrete instance of `ManagedClusterArrayInput` via:
//
//	ManagedClusterArray{ ManagedClusterArgs{...} }
type ManagedClusterArrayInput interface {
	pulumi.Input

	ToManagedClusterArrayOutput() ManagedClusterArrayOutput
	ToManagedClusterArrayOutputWithContext(context.Context) ManagedClusterArrayOutput
}

type ManagedClusterArray []ManagedClusterInput

func (ManagedClusterArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ManagedCluster)(nil)).Elem()
}

func (i ManagedClusterArray) ToManagedClusterArrayOutput() ManagedClusterArrayOutput {
	return i.ToManagedClusterArrayOutputWithContext(context.Background())
}

func (i ManagedClusterArray) ToManagedClusterArrayOutputWithContext(ctx context.Context) ManagedClusterArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedClusterArrayOutput)
}

// ManagedClusterMapInput is an input type that accepts ManagedClusterMap and ManagedClusterMapOutput values.
// You can construct a concrete instance of `ManagedClusterMapInput` via:
//
//	ManagedClusterMap{ "key": ManagedClusterArgs{...} }
type ManagedClusterMapInput interface {
	pulumi.Input

	ToManagedClusterMapOutput() ManagedClusterMapOutput
	ToManagedClusterMapOutputWithContext(context.Context) ManagedClusterMapOutput
}

type ManagedClusterMap map[string]ManagedClusterInput

func (ManagedClusterMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ManagedCluster)(nil)).Elem()
}

func (i ManagedClusterMap) ToManagedClusterMapOutput() ManagedClusterMapOutput {
	return i.ToManagedClusterMapOutputWithContext(context.Background())
}

func (i ManagedClusterMap) ToManagedClusterMapOutputWithContext(ctx context.Context) ManagedClusterMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ManagedClusterMapOutput)
}

type ManagedClusterOutput struct{ *pulumi.OutputState }

func (ManagedClusterOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ManagedCluster)(nil)).Elem()
}

func (o ManagedClusterOutput) ToManagedClusterOutput() ManagedClusterOutput {
	return o
}

func (o ManagedClusterOutput) ToManagedClusterOutputWithContext(ctx context.Context) ManagedClusterOutput {
	return o
}

// Number of IOPS for storage, required if diskType is `gp3`
func (o ManagedClusterOutput) DiskIops() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.IntPtrOutput { return v.DiskIops }).(pulumi.IntPtrOutput)
}

// Size of the data disks, in gigabytes
func (o ManagedClusterOutput) DiskSize() pulumi.IntOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.IntOutput { return v.DiskSize }).(pulumi.IntOutput)
}

// Throughput in MB/s for storage, required if diskType is `gp3`
func (o ManagedClusterOutput) DiskThroughput() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.IntPtrOutput { return v.DiskThroughput }).(pulumi.IntPtrOutput)
}

// Storage class of the data disks (find the list of valid values below)
func (o ManagedClusterOutput) DiskType() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.StringOutput { return v.DiskType }).(pulumi.StringOutput)
}

// DNS address of the cluster
func (o ManagedClusterOutput) DnsName() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.StringOutput { return v.DnsName }).(pulumi.StringOutput)
}

// Instance type of the managed cluster (find the list of valid values below)
func (o ManagedClusterOutput) InstanceType() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.StringOutput { return v.InstanceType }).(pulumi.StringOutput)
}

// Name of the managed cluster
func (o ManagedClusterOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// ID of the network in which the managed cluster exists
func (o ManagedClusterOutput) NetworkId() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.StringOutput { return v.NetworkId }).(pulumi.StringOutput)
}

// ID of the project in which the managed cluster exists
func (o ManagedClusterOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.StringOutput { return v.ProjectId }).(pulumi.StringOutput)
}

// Determines whether to run no projections, system projections only, or system and user projections (find the list of valid values below) Defaults to `off`.
func (o ManagedClusterOutput) ProjectionLevel() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.StringPtrOutput { return v.ProjectionLevel }).(pulumi.StringPtrOutput)
}

// Protection from an accidental cluster deletion Defaults to `false`.
func (o ManagedClusterOutput) Protected() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.BoolPtrOutput { return v.Protected }).(pulumi.BoolPtrOutput)
}

// Region in which the cluster was created. Determined by the region of the Network
func (o ManagedClusterOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// Provider in which the cluster was created. Determined by the provider of the Network.
func (o ManagedClusterOutput) ResourceProvider() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.StringOutput { return v.ResourceProvider }).(pulumi.StringOutput)
}

// Server version to provision (find the list of valid values below)
func (o ManagedClusterOutput) ServerVersion() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.StringOutput { return v.ServerVersion }).(pulumi.StringOutput)
}

// Server version tag to upgrade to (find the list of valid values below). If a tag is provided and it's higher than what's in state, this will prompt an in-place upgrade.
func (o ManagedClusterOutput) ServerVersionTag() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.StringOutput { return v.ServerVersionTag }).(pulumi.StringOutput)
}

// Topology of the managed cluster (`single-node` or `three-node-multi-zone`)
func (o ManagedClusterOutput) Topology() pulumi.StringOutput {
	return o.ApplyT(func(v *ManagedCluster) pulumi.StringOutput { return v.Topology }).(pulumi.StringOutput)
}

type ManagedClusterArrayOutput struct{ *pulumi.OutputState }

func (ManagedClusterArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ManagedCluster)(nil)).Elem()
}

func (o ManagedClusterArrayOutput) ToManagedClusterArrayOutput() ManagedClusterArrayOutput {
	return o
}

func (o ManagedClusterArrayOutput) ToManagedClusterArrayOutputWithContext(ctx context.Context) ManagedClusterArrayOutput {
	return o
}

func (o ManagedClusterArrayOutput) Index(i pulumi.IntInput) ManagedClusterOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ManagedCluster {
		return vs[0].([]*ManagedCluster)[vs[1].(int)]
	}).(ManagedClusterOutput)
}

type ManagedClusterMapOutput struct{ *pulumi.OutputState }

func (ManagedClusterMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ManagedCluster)(nil)).Elem()
}

func (o ManagedClusterMapOutput) ToManagedClusterMapOutput() ManagedClusterMapOutput {
	return o
}

func (o ManagedClusterMapOutput) ToManagedClusterMapOutputWithContext(ctx context.Context) ManagedClusterMapOutput {
	return o
}

func (o ManagedClusterMapOutput) MapIndex(k pulumi.StringInput) ManagedClusterOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ManagedCluster {
		return vs[0].(map[string]*ManagedCluster)[vs[1].(string)]
	}).(ManagedClusterOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ManagedClusterInput)(nil)).Elem(), &ManagedCluster{})
	pulumi.RegisterInputType(reflect.TypeOf((*ManagedClusterArrayInput)(nil)).Elem(), ManagedClusterArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ManagedClusterMapInput)(nil)).Elem(), ManagedClusterMap{})
	pulumi.RegisterOutputType(ManagedClusterOutput{})
	pulumi.RegisterOutputType(ManagedClusterArrayOutput{})
	pulumi.RegisterOutputType(ManagedClusterMapOutput{})
}
